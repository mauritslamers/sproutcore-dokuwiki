a:53:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:46:"An overview of the data store and its concepts";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:63;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:9:"The store";i:1;i:2;i:2;i:63;}i:2;i:63;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:63;}i:6;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:86;}i:7;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:7:"Concept";i:1;i:3;i:2;i:86;}i:2;i:86;}i:8;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:86;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:103;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1274:"
The store inside an application should be regarded as the in-memory storage of data the application needs to handle.
Its role in the application is the source of all data (or records) in the application and it provides ways to perform queries and searches on that data.
What the store doesn't do is send record instances (objects) around inside the application. This would cause a real management problem as the application then has to track all versions of that record in all parts of the application. Instead, the store sends a reference, a pointer to the record. This reference sometimes looks like an object (materialized), and sometimes it will be an index, the so-called storeKey. The store will keep the original data in its memory as a data hash.
When a record changes, those changes will be automatically forwarded to the store. The store will store the changes in its datahash of that record and propagate all changes throughout the application, making sure that all parts of the applications that have some kind of reference to that data (for example in query results etc) use the same version of that particular record. This automatic propagation of changes is also the reason you need to create, update, refresh or destroy data using the store as an inbetween.";}i:2;i:104;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1378;}i:12;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1380;}i:13;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"Application side";i:1;i:3;i:2;i:1380;}i:2;i:1380;}i:14;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1380;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1406;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:300:"
The application side of the store interactions consists of the functions find (with or without using a query), createRecord, updateRecord, (retrieveRecord) and destroyRecord. By default the changes these functions cause will be buffered until the function commitChanges is called by the application.";}i:2;i:1407;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1707;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1707;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:599:"Most data inside desktop grade applications is usually stored in a relational database. Inside these relational databases the data consists of entities and relations. Because the data normally also needs to be represented and searched for in the same way, the store needs models to be able to identify records of a fixed makeup and distinguish between records of the same makeup. These models don't necessarily need to follow the makeup of the database tables but are very useful in managing data. Models inside SC are derived from the SC.Record class and the store uses them to distinguish records.";}i:2;i:1709;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2308;}i:21;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2310;}i:22;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Data source concept";i:1;i:3;i:2;i:2310;}i:2;i:2310;}i:23;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2310;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2339;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:555:"
An application is useless of course if the store doesn't contain data, so there has to be a mechanism that fills the store. There isn't a unified way of talking to servers however as there are many types of back-ends and interfaces. To make the transition from the back end to the store possible, there needs to be a translation engine, which in SC is called a data source. The data source will translate calls made by the applicationto the store into requests to the server, it will manage the data returning from the server and feed it into the store. ";}i:2;i:2340;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2895;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2895;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:409:"By design the store will accept only a single data source. At the same time, the concept behind a data source is that it is used with a single back end only. 
In most cases this will be sufficient, but in case multiple data sources are needed a wrapper exists which contains multiple data sources, but pretends to be a single data source. This concept is called a cascading data source and is supported by SC.";}i:2;i:2897;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3306;}i:30;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3308;}i:31;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Data source workings";i:1;i:3;i:2;i:3308;}i:2;i:3308;}i:32;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3308;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3338;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:535:"
When the store receives a request from the application, it will pass on the request to the data source. The store can pass on the request directly, or indirectly in case of changes. From the available information, the data source needs to determine what to request exactly, create a request and send it to the back end. A data source will always interact with the store using the storeKey. Every type of information about the record (such as model, record status, record data etc) can be retrieved from the store using the storeKey.  ";}i:2;i:3339;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3874;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3874;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:334:"When sending requests to the data source, the store will call the functions fetch, createRecord, retrieveRecord, updateRecord and destroyRecord. (Plural versions of the last 4 functions also exist, but the default implementation of these functions will call these four functions for every change and this is sufficient in most cases).";}i:2;i:3876;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4210;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4210;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1090:"The fetch function is called whenever a query is performed. A query can either be local or remote, denoting whether the query is intended to be executed on the stores memory or to be sent to the back end. When the query is local, the data sources fetch function will only be called when the query is first performed. When the query is remote, the fetch function will always be called.
The reason this separate function exists is because the store cannot know how many records the server will return or whether the records already exist in its memory. When the data is received from the back end, the records need to be loaded into the store with loadRecords. This function will check whether a record of that type and a specific primaryKey value already exists in the stores memory. When it already exists, it will update it. When it doesn't yet exist, the store will store the new records. The function will return a set of storeKeys for the records provided. To finish the request, the query also needs to be updated on the new record data, which can be done by calling loadQueryResults. ";}i:2;i:4212;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5302;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5302;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:518:"The function createRecord, updateRecord and destroyRecord can be called by the store as a result of a call to commitRecords by the application. The data source needs to send a request to the back end to store the changes. If the call is successful, the dataSourceDidComplete function needs to be called. When performing a create action, the new primary key has to be set on the data given to the function. When performing an update action, the new data can be given. When performing a destroy action no data is needed.";}i:2;i:5304;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5822;}i:45;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5822;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:260:"The function retrieveRecord is mostly used by the store to get the latest version of a record when it is selected in the interface. When the server returns the newest version, the dataSourceDidComplete needs to be called with the newest version of that record.";}i:2;i:5824;}i:47;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6084;}i:48;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6084;}i:49;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"When dealing with records having childRecords (also called nested records) there is no real difference, as the data hash is just one record of a certain type to the store and the data source.";}i:2;i:6086;}i:50;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6277;}i:51;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6279;}i:52;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:6279;}}