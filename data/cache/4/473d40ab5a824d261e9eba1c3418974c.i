a:62:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"Concepts in use in SC";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"SC follows the Cocoa/NeXTStep implementation model of the MVC design pattern. Two concepts are used from Cocoa:";}i:2;i:39;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:150;}i:6;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:152;}i:7;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Inheritance model";i:1;i:2;i:2;i:152;}i:2;i:152;}i:8;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:152;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:181;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:443:"
Default behaviour is defined in a base object and every object in the system needing that behaviour inherits from that base object. 
So, every object inside an SC app inherits from SC.Object. Next a set of first level inheritance objects exists, like SC.View and SC.Controller,
which define default behaviour for views, controllers. All types of controllers will need to inherit from SC.Controller to be used as a controller inside an SC app.";}i:2;i:182;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:625;}i:12;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:627;}i:13;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"Observer/binding pattern";i:1;i:2;i:2;i:627;}i:2;i:627;}i:14;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:627;}i:15;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:665;}i:16;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:8:"Bindings";i:1;i:3;i:2;i:665;}i:2;i:665;}i:17;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:665;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:684;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:527:"
To prevent having to write code to update every value in every controller and view, SC uses a binding: a link you define which binds the value from a property on a controller or view to a local property. Bindings are used for inter-object communication. Because of this binding magic, you never have to set values to your views manually, you just bind the views properties (that matter) to properties on the controller you want to use to control the view. Setting a value to the controller will automatically update the view. ";}i:2;i:685;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1212;}i:21;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1214;}i:22;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:9:"Observers";i:1;i:3;i:2;i:1214;}i:2;i:1214;}i:23;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1214;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1233;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:412:"
Observers are special type of functions. These functions are executed whenever a property they observe changes value.
Observers are used for internal object matters and internal object matters only. 
You have to be aware though of the danger of observers: endless loops. If the observer changes a value that indirectly also changes the value it is observing, there will most certainly result in an endless loop.";}i:2;i:1234;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1646;}i:27;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1649;}i:28;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Inter-object observing";i:1;i:3;i:2;i:1649;}i:2;i:1649;}i:29;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1649;}i:30;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1681;}i:31;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"
To have an inter-object observer, create a binding to that value, and then create an observer observing the value.";}i:2;i:1682;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1797;}i:33;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1799;}i:34;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"How does SC implement this in JS";i:1;i:3;i:2;i:1799;}i:2;i:1799;}i:35;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1799;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1841;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"
In order to make this work inside JavaScript, using the getters and setters is essential. If you want to update a property and want to have the observers watching that property to fire, you need to use the .set() function to set the value. The firing of the observers caused by this set function takes place as part of the RunLoop (see below for a short explanation on that concept).";}i:2;i:1842;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2226;}i:39;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2228;}i:40;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:8:"Examples";i:1;i:3;i:2;i:2228;}i:2;i:2228;}i:41;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2228;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2246;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"
Simple observer: ";}i:2;i:2247;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2265;}i:45;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:227:"
myApp.myController = SC.Controller.extend({
    
    property: 1,
    
    property2: 0,
    
    propObs: function(){ 
       var val = this.get('property'); 
       this.set('property2',val+1); 
    }.observes('property')
}
";i:1;N;i:2;N;}i:2;i:2272;}i:46;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2510;}i:47;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"Mixins";i:1;i:2;i:2;i:2510;}i:2;i:2510;}i:48;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2510;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2528;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:372:"
In order to do multiple inheritance without having the hassle to deal with multiple origin changes (which is one of the nastiest parts of OO), SC copied Rubys MixIn feature. a mixin is used when you want to copy behaviour without keeping a connection with the object that originally defined that behaviour.
A mixin is literally copied onto the object you want it to be on";}i:2;i:2529;}i:51;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:2901;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2904;}i:53;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2907;}i:54;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:7:"RunLoop";i:1;i:2;i:2;i:2907;}i:2;i:2907;}i:55;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2907;}i:56;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2926;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:492:"
The RunLoop is a concept to prevent the application having to run constantly. As JavaScript is event based, a constantly running application wouldn't work well, and would need much resources. So, what happens is that as soon as an event has finished, an SC.RunLoop is started to propagate all changes throughout the entire application, and fire all observers and bindings. In a browser the RunLoop is mostly executed after every event supported by the browser, such as mouseover, onclick etc";}i:2;i:2927;}i:58;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:3419;}i:59;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3422;}i:60;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3423;}i:61;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:3423;}}